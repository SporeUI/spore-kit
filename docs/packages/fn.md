<!-- Generated by documentation.js. Update this documentation by updating the source code. -->

## spore-kit-fn

-   **See: [https://github.com/SporeUI/spore-kit/tree/master/packages/fn][1]**

# 函数包装，获取特殊执行方式

### Examples

```javascript
// 统一引入 spore-kit
var $kit = require('spore-kit');
console.info($kit.fn.delay);

// 单独引入 spore-kit-fn
var $fn = require('spore-kit-fn');
console.info($fn.delay);

// 单独引入一个方法
var $delay = require('spore-kit-fn/delay');
```

## delay

包装为延迟触发的函数

用于处理密集事件，延迟时间内同时触发的函数调用，最终只在最后一次调用延迟后，执行一次。

### Parameters

-   `fn` **[Function][2]** 要延迟触发的函数
-   `duration` **[Number][3]** 延迟时间(ms)
-   `bind` **[Object][4]?** 函数的this指向

### Examples

```javascript
var comp = {
	countWords : function(){
		console.info(this.length);
	}
};

 // 疯狂点击 input ，停下来 500 ms 后，触发函数调用
$('#input').keydown(delay(function(){
	this.length = $('#input').val().length;
	this.countWords();
}, 500, comp));
```

Returns **[Function][2]** 经过包装的延迟触发函数

## lock

包装为触发一次后，预置时间内不能再次触发的函数

类似于技能冷却。

### Parameters

-   `fn` **[Function][2]** 要延迟触发的函数
-   `delay` **[Number][3]** 延迟时间(ms)
-   `bind` **[Object][4]?** 函数的 this 指向

### Examples

```javascript
var request = function () {
	console.info('do request');
};
$('#input').keydown(lock(request, 500));
// 第一次按键，就会触发一次函数调用
// 之后连续按键，仅在 500ms 结束后再次按键，才会再次触发 request 函数调用
```

Returns **[Function][2]** 经过包装的冷却触发函数

## once

包装为仅触发一次的函数

被包装的函数智能执行一次，之后不会再执行

### Parameters

-   `fn` **[Function][2]** 要延迟触发的函数
-   `bind` **[Object][4]?** 函数的 this 指向

### Examples

```javascript
var fn = once(function () {
	console.info('output');
});
fn(); // 'output'
fn(); // will do nothing
```

Returns **[Function][2]** 该函数仅能触发执行一次

## queue

包装为一个队列，按设置的时间间隔触发任务函数

插入队列的所有函数都会执行，但每次执行之间都会有一个固定的时间间隔。

### Parameters

-   `fn` **[Function][2]** 要延迟触发的函数
-   `delay` **[Number][3]** 延迟时间(ms)
-   `bind` **[Object][4]?** 函数的 this 指向

### Examples

```javascript
var t1 = Date.now();
var doSomthing = queue(function (index) {
	console.info(index + ':' + (Date.now() - t1));
}, 200);
// 每隔200ms输出一个日志。
for(var i = 0; i < 10; i++){
	doSomthing(i);
}
```

Returns **[Function][2]** 经过包装的队列触发函数

## prepare

包装为一个条件触发管理器

-   调用管理器的 ready 函数来激活条件。
-   之前插入管理器的函数按队列顺序执行。
-   之后插入管理器的函数立即执行。
-   作用机制类似 jQuery.ready, 可以设置任何条件。

### Examples

```javascript
// 生成一个管理器函数 timeReady
var timeReady = prepare();

// 设置条件为2秒后就绪
setTimeout(function () {
	timeReady.ready();
}, 2000);

// 调用管理器函数 timeReady，插入要执行的任务函数
timeReady(function () {
	// 2 秒后输出 1
	console.info(1);
});

// 调用管理器函数 timeReady，插入要执行的任务函数
timeReady(function () {
	// 2 秒后输出 2
	console.info(2);
});

// 2100ms 后执行
setTimeout(function () {
	// 调用管理器函数 timeReady，插入要执行的任务函数
	timeReady(function () {
		// 立即执行，输出 3
		console.info(3);
	});
}, 2100);
```

Returns **[Function][2]** 条件触发管理器函数，传入一个 function 作为任务执行函数参数

### prepare.ready

激活任务管理器的触发条件，在此之前插入管理器的任务按队列顺序执行，之后插入的任务函数立即执行。

## reqular

包装为规律触发的函数，用于降低密集事件的处理频率

在疯狂操作期间，按照规律时间间隔，来调用任务函数

### Parameters

-   `fn` **[Function][2]** 要延迟触发的函数
-   `delay` **[Number][3]** 延迟时间(ms)
-   `bind` **[Object][4]?** 函数的 this 指向

### Examples

```javascript
var comp = {
	countWords : function(){
		console.info(this.length);
	}
};
// 疯狂按键，每隔 200ms 才有一次按键有效
$('#input').keydown(regular(function(){
	this.length = $('#input').val().length;
	this.countWords();
}, 200, comp));
```

Returns **[Function][2]** 经过包装的定时触发函数

[1]: https://github.com/SporeUI/spore-kit/tree/master/packages/fn

[2]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/function

[3]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number

[4]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object
